# 一、问题的提出

## 1.关系模式

关系模式由五部分组成，是一个五元组： **R(U, D, DOM, F)，**关系名**R**是符号化的元组语义

- **U**为一组属性
- **D**为属性组**U**中的属性所来自的域
- **DOM**为属性到域的映射
- **F**为属性组**U**上的一组数据依赖

**D**、**DOM**与模式设计关系不大，因此在本章中把关系模式看作一个三元组：**R<U,F>**

当且仅当**U**上的一个关系**r**满足**F**时，**r**称为关系模式**R<U,F>**的一个关系 

作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（**1NF**）

数据依赖

- 是一个关系内部属性与属性之间的一种约束关系
- 通过属性间值的相等与否体现出来的数据间相互联系
- 是现实世界属性间相互联系的抽象
- 是数据内在的性质
- 是语义的体现

数据依赖

- 函数依赖
- 多值依赖

## 2.函数依赖

描述一个学生关系，可以有学号、姓名、系名等属性。

一个学号只对应一个学生，一个学生只在一个系中学习，“学号”值确定后，学生的姓名及所在系的值就被唯一确定。

- **Sname = f(Sno)**，**Sdept = f(Sno)，**即**Sno**函数决定**Sname**
- **Sno**函数决定**Sdept，**记作**Sno→Sname**，**Sno→Sdept** 
- 假设学校教务的数据库模式用一个单一的关系模式
- **Student**来表示，则该关系模式的属性集合为：
- **U** ＝ **{Sno, Sdept, Mname, Cno, Grade}**

现实世界的已知事实（语义）：

- 一个系有若干学生， 但一个学生只属于一个系;
- 一个系只有一名（正职）负责人；
- 一个学生可以选修多门课程，每门课程有若干学生选修；
- 每个学生学习每一门课程有一个成绩。

由此可得到属性组**U**上的一组函数依赖 **F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}**

![img](https://img2020.cnblogs.com/blog/1861185/202005/1861185-20200519184827832-1773018669.png)

关系模式**Student<U, F>**中存在的问题：

- 数据冗余
    - 浪费大量的存储空间
    - 每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。
- 更新异常
    - 数据冗余，更新数据时，维护数据完整性代价大。
    - 某系更换系主任后，必须修改与该系学生有关的每一个元组。
- 插入异常
    - 如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。 
- 删除异常（**Deletion Anomalies**）
    - 如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。 

**Student**关系模式不是一个好的模式,一个“好”的模式不会发生插入异常、删除异常和更新异常，数据冗余尽可能少。

- 原因:由存在于模式中的某些数据依赖引起的。
- 解决方法:用规范化理论改造关系模式来消除其中不合适的数据依赖
- 把这个单一的模式分成三个关系模式：
    - **S(Sno,Sdept,Sno → Sdept);**
    - **SC(Sno,Cno,Grade,(Sno,Cno) → Grade);**
    - **DEPT(Sdept,Mname,Sdept → Mname);**
- 这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。

# 二、规范化

## 1. 函数依赖

### **（1）函数依赖定义** 

设**R(U)**是一个属性集**U**上的关系模式，**X**和**Y**是**U**的子集。若对于**R(U)**的任意一个可能的关系**r**，

**r**中不可能存在两个元组在**X**上的属性值相等， 而在**Y**上的属性值不等， 则称“**X**函数确定 **Y**” 或 “**Y**函数依赖于**X**”**，记作**X→Y。

**Student(Sno, Sname, Ssex, Sage, Sdept),**     

  假设不允许重名，则有**:**

**Sno → Ssex**，   **Sno → Sage**

**Sno → Sdept**，  **Sno ←→ Sname**

**Sname → Ssex**， **Sname → Sage**

**Sname → Sdept**

但**Ssex** ↛ **Sage, Ssex** ↛ **Sdept**

**函数依赖不是指关系模式R的某个或某些关系实例满足的**约束条件，而是指R的所有关系实例均要满足的约束条件。

**函数依赖是语义范畴的概念，只能根据数据的语义来确定一个函数依赖。**

### **（2）**平凡函数依赖与非平凡函数依赖 

X → Y，但Y ⊈ X则称X → Y是非平凡的函数依赖。

X → Y，但Y ⊆ X 则称X → Y是平凡的函数依赖。

对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明， 总是讨论非平凡函数依赖。

若X→Y，则X称为这个函数依赖的决定因素

若X→Y，Y→X，则记作X←→Y。

若Y不函数依赖于X，则记作X↛Y。

### **（3）**完全函数依赖与部分函数依赖 

在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’↛ Y, 则称Y对X完全函数依赖，记作X →F Y。

若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X →P Y

### **（4）**传递函数依赖

在R(U)中，如果X → Y(Y ⊈ X)，Y ↛ X， Y → Z，Z ⊈ Y, 则称Z对X传递函数依赖。记为：X → Z。

如果Y → X, 即X ←→ Y，则Z直接依赖于X，而不是传递函数依赖。
**[例]** 在关系Std(Sno, Sdept, Mname)中，有：
Sno → Sdept，Sdept → Mname，
Mname传递函数依赖于Sno

## 2. 码

设**K**为**R<U,F>**中的属性或属性组合。若**K →FU**，则**K**称为**R**的一个候选码

如果**U**部分函数依赖于**K**，即**K → U,**则**K**称为超码。候选码是最小的超码，即**K**的任意一个真子集都不是候选码。

若关系模式**R**有多个候选码，则选定其中的一个做为主码

包含在任何一个候选码中的属性 ，称为主属性

不包含在任何码中的属性称为非主属性

全码：整个属性组是码，称为全码

关系模式**R**中属性或属性组**X**并非**R**的码，但**X**是另一个关系模式的码，则称**X**是**R**的外码。 

**SC(Sno,Cno,Grade)**中，**Sno**不是码

**Sno**是**S(Sno,Sdept,Sage)**的码，则**Sno**是**SC**的外码 

主码与外部码一起提供了表示关系间联系的手段

## 3. 范式

范式是符合某一种级别的关系模式的集合。

关系数据库中的关系必须满足一定的要求。

 满足不同程度要求的为不同范式。

范式的种类：

- 第一范式**(1NF)**
- 第二范式**(2NF)** 
- 第三范式**(3NF)** 
- **BC**范式**(BCNF)**
- 第四范式**(4NF)** 
- 第五范式**(5NF)**

各种范式之间存在联系：
$$
1NF ⊃ 2NF ⊃ 3NF ⊃ BCNF ⊃ 4NF ⊃ 5NF
$$
某一关系模式**R**为第**n**范式，可简记为**R**∈**nNF**。 

一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化

![img](https://img2020.cnblogs.com/blog/1861185/202005/1861185-20200519200649363-1561490188.png)

 

- 1NF

- - 数据库表的每一列都是不可分割的基本数据项
    - 同一列中不能有多个值
    - 即实体中的某个属性不能有多个值或者不能有重复的属性

## 4. 2NF

- 定义：若关系模式**R** ∈ **1NF**，并且每一个非主属性都完全函数依赖于任何一个候选码，则**R** ∈ **2NF**

**[例6.4]**S-L-C(Sno,Sdept,Sloc,Cno,Grade)**， **Sloc为学生的住处，并且每个系的学生住在同一个地方。S-L-C的码为(Sno,Cno)。

函数依赖有

**(Sno,Cno) →**F **Grade**

**Sno → Sdept, (Sno,Cno) →**P **Sdept**

**Sno → Sloc, (Sno,Cno) →**P **Sloc**

**Sdept → Sloc(每个系的学生住在一个地方)**

![img](https://img2020.cnblogs.com/blog/1861185/202005/1861185-20200519201455017-908521610.png)

**非主属性Sdept、Sloc并不完全依赖于码，关系模式S-L-C不属于2NF** 

一个关系模式不属于**2NF**，会产生以下问题：

- 插入异常

    - 如果插入一个新学生，但该生未选课，即该生无**Cno**，由于插入元组时，必须给定码值，因此插入失败 

- 删除异常

     

    - 如果**S4**只选了一门课**C3**，现在他不再选这门课，则删除**C3**后，整个元组的其他信息也被删除了。

- 修改复杂

- - 如果一个学生选了多门课，则**Sdept**，**Sloc**被存储了多次。如果该生转系，则需要修改所有相关的**Sdept**和 **Sloc**，造成修改的复杂化。

- 出现这种问题的原因

     ：

    - 例子中有两类非主属性
        - 一类如**Grade**，它对码完全函数依赖 
        - 另一类如**Sdept**、**Sloc**，它们对码不是完全函数依赖 

- 解决方法：

    - 用投影分解把关系模式**S-L-C**分解成两个关系模式
        - **SC(Sno,Cno,Grade)**
        - **S-L(Sno,Sdept,Sloc)**

**SC的函数依赖**

 ![img](https://img2020.cnblogs.com/blog/1861185/202005/1861185-20200519202846175-1254215240.png)

**SL中的函数依赖** 

![img](https://img2020.cnblogs.com/blog/1861185/202005/1861185-20200519202912680-96202237.png)

**SC**的码为**(Sno,Cno),S-L**的码为**Sno**，这样使得非主属性对码都是完全函数依赖了

## 5. 3NF

- 定义：设关系模式 **R<U,F>** ∈ **1NF,**若**R**中不存在这样的码**X**、属性组**Y**及非主属性**Z**（**Z** ⊇ **Y**）**,** 使得**X→Y**，**Y→Z**成立，**Y** ↛ **X**不成立，则称 **R<U,F>** ∈ **3NF**。
- 也就是若**R** ∈ **3NF**，则**每一个非主属性既不部分依赖于码也不传递依赖于码**

**表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。**

**也就是说，对于一个满足2NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除**

**SC**没有传递依赖，因此**SC**∈**3NF** 

**S-L**中**Sno →Sdept( Sdept** ↛ **Sno), Sdept→Sloc**，可得**Sno** 传**→**递**Sloc**。

解决的办法：分解传递依赖

将**S-L**分解成

**S-D(Sno,Sdept)**∈**3NF**

**D-L(Sdept,Sloc)**∈**3NF**

## 6.BCNF

- 定义：设关系模式**R<U,F>** ∈ **1NF**，若**X → Y**且**Y** ⊈ **X**时**X**必含有码，则**R<U,F>** ∈ **BCNF**。 

换言之，在关系模式**R<U,F>**中，如果每一个决定属性集都包含候选码，则**R** ∈ **BCNF**。

**BCNF**的关系模式所具有的性质

- 所有非主属性都完全函数依赖于每个候选码 
- 所有主属性都完全函数依赖于每个不包含它的候选码
- 没有任何属性完全函数依赖于非码的任何一组属性 

如果一个关系数据库中的所有关系模式都属于 **BCNF**，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。

 

**[**例**6.5]**考察关系模式**C(Cno,Cname,Pcno)** 

它只有一个码**Cno**，没有任何属性对**Cno**部分依赖或传递依赖，所以**C**∈**3NF**。 

同时**C**中**Cno**是唯一的决定因素，所以**C**∈**BCNF**。

对于关系模式**SC(Sno,Cno,Grade)**可作同样分析。

 

**[**例**6.6]** 关系模式**S(Sno,Sname,Sdept,Sage)**，

 假定**Sname**也具有唯一性，那么**S**就有两个码，这两个码都由单个属性组成，彼此不相交。 

其他属性不存在对码的传递依赖与部分依赖，所以**S**∈**3NF**。

同时**S**中除**Sno**，**Sname**外没有其他决定因素，所以**S**也属于**BCNF**。

 

**[**例**6.7]** 关系模式**SJP(S,J,P)**中，**S**是学生，**J**表示课程，**P**表示名次。每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一个学生（即没有并列名次）。

由语义可得到函数依赖： **(S,J)→P**；**(J,P) → S****(S,J)**与**(J,P)**都可以作为候选码。

关系模式中没有属性对码传递依赖或部分依赖，所以**SJP** ∈ **3NF**。

除 **(S,J)** 与 **(J,P)** 以外没有其他决定因素，所以**SJP** ∈ **BCNF**。

 

**[**例**6.8]** 关系模式**STJ(S,T,J)**中，**S**表示学生，**T**表 示教师，**J**表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。

由语义可得到函数依赖：**(S,J)→T**；**(S,T)→J**；**T→J**

因为没有任何非主属性对码传递依赖或部分依赖，**STJ**∈**3NF**。

因为**T**是决定因素，而**T**不包含码，所以**STJ ⊈** **BCNF**关系。

![img](https://img2020.cnblogs.com/blog/1861185/202005/1861185-20200519203527784-427984058.png)

 

对于不是**BCNF**的关系模式，仍然存在不合适的地方。

非**BCNF**的关系模式也可以通过分解成为**BCNF**。 例如**STJ**可分解为**ST(S,T)**与**TJ(T,J)**，它们都是 **BCNF**。

**3NF**和**BCNF**是在函数依赖的条件下对模式分解所能达到的分离程度的测度。 

一个模式中的关系模式如果都属于**BCNF**，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常 

**3NF**的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。

## 7. 多值依赖 

例**[6.9]**设学校中某一门课程由多个教师讲授，他们 使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用

用关系模式**Teaching(C,T,B)**来表示课程**C**、教师**T**和参考书**B**之间的关系。

**非规范化的关系：**

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200621172647588-1452695342.png)

 

**规范化后的二维表：**

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200621172728838-1765015461.png)

 

- **Teaching**具有唯一候选码**(C,T,B)**， 即全码。

- **Teaching** ∈ **BCNF**

- 存在的问题：

- - 数据冗余度大：有多少名任课教师，参考书就要存储多少次
    - 增加操作复杂：当某一课程增加一名任课教师时，该课程有多少本参考书，就必须插入多少个元组
    - 删除操作复杂：某一门课要去掉一本参考书，该课程有多少名教师，就必须删除多少个元组
    - 修改操作复杂：某一门课要修改一本参考书，该课程有多少名教师，就必须修改多少个元组

- 原因

    - 存在多值依赖

- 定义：设**R(U)**是属性集**U**上的一个关系模式。**X,Y,Z**是**U**的子集，并且**Z=U-X-Y**。关系模式**R(U)**中多值依赖**X→→Y**成立，当且仅当对**R(U)**的任一关系**r**，给定的一对**(x,z)**值，有一组**Y**的值，这组值仅仅决定于**x**值而与**z**值无关。
- 例 **Teaching**（**C, T, B**）

  对于**C**的每一个值，**T**有一组值与之对应，而不论**B**取何值。因此**T**多值依赖于**C**，即**C→→T**。 

- 多值依赖的另一个等价的定义

在 ***R\(*U\)** 的任一关系 r 中，如果存在元组 t，s 使得 t [X ] = s [X ]**，那么就必然存在元组w，v ∈ r，（w ,v可以与s，t相同）**,使得**w\[ X ] = v [ X ] = t [ X]**，而**w [Y ] = t [Y ]**，**w [Z ] = s[Z ]**，**v [Y] = s [Y ]**，**v [Z ] = t[Z ]**（即交换**s，t元组的Y值所得的两个新元组必在r 中则Y多值依赖于X，记为X→→Y。这里X，Y是U的子集，Z = U-X-Y**。

- 平凡多值依赖和非平凡的多值依赖
    - 若**X→→Y**，而**Z**＝**Ф**，即**Z**为空，则称**X→→Y**为平 凡的多值依赖。
    - 否则称**X→→Y**为非平凡的多值依赖。

 

**[**例**6.10]**关系模式**WSC(W,S,C)**中，**W**表示仓库，**S** 表示保管 员，**C** 表示商品。假设每个仓库有若干个保管员，有若干种商品。每个保管员保管所在仓库的所有商品，每种商品被所有保管员保管。

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200627174451967-2016015155.png)

 

 

- 按照语义对于**W**的每一个值**W**i**，**S**有一个完整的集 合与之对应而不问**C**取何值。所以**W→→S。
- 如下图所示
    - 对应**W**的某一个值**Wi**的全部**S**值记作 **{S}**Wi**（表示此仓库 工作的全部保管员），全部**C**值记作 **{C}Wi（表示在此仓 库中存放的所有商品）
    - 应当有 **{S}** **Wi**中的每一个值和**{C}**Wi**中的每一个**C值对应
    - 于是 **{S}** **Wi** 与 **{C}** **Wi** 之间正好形成一个完全二分图，因而**W→→S**。
    - 由于**C**与**S**的完全对称性，必然有**W→→C**成立。

 ![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200627174646599-752989523.png)

 

 

 

- 多值依赖的性质

    - 多值依赖具有对称性

    - - 即若**X→→Y，则X→→Z**，其中**Z＝U－X－Y**
        - 多值依赖的对称性可以用完全二分图直观地表示出来。
        - 从**[**例**6.10]** 容易看出，因为每个保管员保管所有商品，同时每种商品被所有保管员保管，显然若**W→→S，必然有W→→C**。

    - 多值依赖具有传递性。即若**X→→Y，Y→→Z， 则X→→Z -Y**。

    - - 函数依赖是多值依赖的特殊情况。即若**X→Y**，则**X→→Y**。
        - 若**X→→Y，X→→Z，则X→→Y∪Z**。
        - 若**X→→Y**，**X→→Z**，则**X→→Y∩Z**。
        - 若**X→→Y**，**X→→Z**，则**X→→Y-Z**，**X→→Z-Y**。

- 多值依赖与函数依赖的区别

    - 多值依赖的有效性与属性集的范围有关
        - 若**X→→Y**在**U**上成立，则在**W (XY ⊆ W ⊆ U)**上一定成立；反之则不然，即**X→→YW (W ⊂U**)上成立，在U上并不一定成立。
        - 原因：多值依赖的定义中不仅涉及属性组X和Y，而且涉及U中其余属性Z。
    - 多值依赖的有效性与属性集的范围有关（续）

    - - 一般地，在**R(U)**上若有**X→→Y**在**W(W ⊂U)**上成立，则称**X→→Y**为**R(U)**的嵌入型多值依赖。
        - 函数依赖**X→Y**的有效性仅决定于**X**、**Y**这两个属性集的值
        - 只要在**R(U)**的任何一个关系**r**中，元组在**X**和**Y**上的值满足定义**6.1**，则函数依赖**X→Y**在任何属性集**W(XY**⊆**W**⊆**U)**上成立。

- - 若函数依赖**X→Y**在**R (U)**上成立，则对于任何**Y’**⊂**Y** 均有**X→Y’**成立。
        - 多值依赖**X→→Y**若在**R(U)**上成立，不能断言对于任何**Y’**⊂**Y**有**X→→Y’**成立。

例如，关系**R(A,B,C,D)**，**A→→BC**成立，当然也有 **A→→D**成立。有**R**的一个关系实例，在此实例上 **A→→B**是不成立的。

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200627175126130-1966254318.png) 

## 8. 4NF

- 定义：关系模式**R< U , F >** ∈ **1NF**，如果对于 **R** 的每个非平凡多值依赖 **X →→ Y**（**Y** ⊈ **X**），**X** 都含有码，则 **R < U , F >**

4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际上是函数依赖。

- 如果一个关系模式是**4NF**， 则必为**BCNF**。
- 在**[**例**6.10]**的**WSC**中，**W →→ S, W →→ C,**依赖。而**W**不是码，关系模式**WSC**的码是**(W,S,C)**，即**All-key**，因此**WSC** ∈ **4NF**。
- 可以把 **WSC** 分解成 **WS(W,S) , WC(W,C)**， **WS** ∈ **4NF**，**WC** ∈ **4NF**。

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200627180337530-1537196436.png) 

# 三、数据依赖的公理系统

## 1. 逻辑蕴含

- 定义：对于满足一组函数依赖 **F** 的关系模式 **R <U,F >** ，其任何一个关系 **r**，若函数依赖 **X→Y** 都成立（即 **r** 中任意两元组 **t**、**s**，若 **t[X]=s[X]** ，则 **t[Y] = s[Y]**），则称**F**逻辑蕴涵 **X → Y**。
- 理解是，我们在R里面任意找一个r关系，对于这个关系的元组s和t，当s和t在属性（组）X上面相等，则s和t在Y属性（组）上也相等。这样被称为，X函数确定Y函数或者说Y函数依赖于X函数（X->Y).

## **2. Armstrong**公理系统 

### （1）三条定律

- 一套推理规则，是模式分解算法的理论基础 
- 用途
    - 求给定关系模式的码
    - 从一组函数依赖求得蕴涵的函数依赖

- 设**U**为属性集总体，**F**是**U** 上的一组函数依赖，于是有关系模式**R <U,F >**。 对**R <U,F>** 来说有以下的推理规则：

- - **A1** 自反律：若**Y** ⊆**X** ⊆**U**，则**X→Y** 为**F**所蕴涵。即 **X→Y 恒成立**
        - 证明：
            - 设**Y** ⊆ **X** ⊆ **U** 。
            - 对**R <U , F>** 的任一关系 **r** 中的任意两个元组**t**、**s**：
            - 若 **t [ X ] = s [ X ]**，由于**Y** ⊆ **X**，有**t [ Y ] = s [ Y ]**，
            - 所以**X → Y**成立，
            - 自反律得证。
            - 自反律的使用并不依赖于**F**。
    - **A2** 增广律：若**X→Y**为**F**所蕴涵，且**Z** ⊆**U**，则**XZ→YZ** 为**F**所蕴涵。
        - 证明：
            - 设 **X → Y** 为 **F** 所蕴涵，且**Z** ⊆ **U** 。
            - 对 **R< U , F >** 的任一关系 **r** 中任意的两个元组 **t**、**s**：
            - 若 **t [ XZ ] = s [ XZ ]**，则有 **t[X] = s[X]** 和 **t[Z] = s[Z]**；
            - 由**X → Y**，于是有 **t [ Y ] = s [ Y ]**，
            - 所以 **t [ YZ ] = s [ YZ ]** ，**XZ → YZ** 为 **F** 所蕴涵，
            - 增广律得证。
    - **A3** 传递律：若**X→Y**及**Y→Z**为**F**所蕴涵，则**X→Z** 为**F**所蕴涵。
        - 证明：
            - 设 **X → Y**及**Y → Z**为 **F** 所蕴涵。
            - 对**R< U , F >** 的任一关系 **r** 中的任意两个元组 **t**、**s**： 
            - 若**t [ X ] = s [ X ]**，由于**X → Y**，有**t [ Y ] = s [ Y ]**；
            - 再由**Y → Z**，有 **t [ Z ] = s [ Z ]**， 
            - 所以**X → Z**为 **F** 所蕴涵，
            - 传递律得证。
    - 注意：由自反律所得到的函数依赖均是平凡的函数依赖**,**

### （2）三条推理规则

根据**A1**，**A2**，**A3**这三条推理规则可以得到下面 

三条推理规则：

- 合并规则：由**X → Y**，**X → Z**，有**X → YZ**。

- 伪传递规则：由**X → Y**，**WY → Z**，有**XW → Z**。

- 分解规则：由 **X → Y**及 **Z** ⊆ **Y** ，有 **X → Z**。

### （3）Armstrong公理系统的有效性、完备性

- 有效性：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F+中；
- 完备性：F+中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来
- 导出和蕴含是两个完全等价的概念

## 3. 函数依赖闭包

根据合并规则和分解规则，可得引理1

- $X → A_1,A_2,… ,A_k$​ 成立的充分必要条件是 $X → A_i$ 成立（**i=1**，**2**，**…**，**k**）

- 闭包定义1：在关系模式 **R < U , F >** 中为 **F** 所逻辑蕴涵的函数依赖的全体叫作 **F** 的闭包，记为 **F** **+**。

    - 由函数依赖集 **F** 计算 **F** **+** 是一件相当费时的事。即使 **F** 很小，**F** **+** 却可能很大
    - 但幸运的是计算 **F** **+** 的目的往往是为了判断函数依赖 **X** **→** **Y** 是否为 **F** 所蕴涵，而根据引理**6.1**，只要知道**Y** ⊆ **X** **+**，就可以断定**X** **→** **Y** 为 **F** 所蕴涵。因此，可以用计算 **X** **+** 代替计算 **F** **+** ，通过判断是否满足**Y** ⊆ **X** **+**来判定**X** **→** **Y** 是否为 **F** 所蕴涵

- 闭包定义2：设 **F** 为属性集 **U** 上的一组函数依赖，**X**、 **Y** ⊆ **U**， **X** **F** **= { A | X → A**能由 **F** 根据 **Armstrong** 公理导出**}**，**X** **F** 称为属性集 **X** 关于函数依赖集 **F** 的闭包。

- 引理**2：**设 **F** 为属性集 **U** 上的一组函数依赖，**X**、**Y** 

    ⊆ 

    **U**，**X → Y**能由 **F** 根据 **Armstrong**公理 导出的充分

    必要条件是

    **Y** ⊆ **X** **F**。

    - 用途：判定 **X → Y** 是否能由 **F** 根据**Armstrong**公理导出的问题，就转化为求出 **X** **F** **+**，判定 **Y** 是否为 **X** **F** **+** 的子集的问题。

求闭包的算法 

算法 求属性集**X**（**X** ⊆ **U**）关于**U**上的函数依赖集 **F** 的闭包 **X** **F**

输入：**X**，**F**

输出：**X** **F**

1. 令 **X** **(0)** **= X** ， **i = 0**
2. 求**B**，这里**B = { A | (** ∃ **V) (** ∃ **W) (V → W** ∈ **F** ∧ **V** ⊆ **X** **(i)** ∧ **A** ∈ **W ) }**。
3. **X** **(i+1)** **= B** ∪ **X**(i) 。
4. 判断**X** **(i+1)** **= X**(i) 。
5. 若**X** **(i+1)** 与 **X** **(i)** 相等或 **X** **(i)** **= U** ，则**X** **(i)** 就是 **X** **F**，算法终止。
6. 若否，则 **i = i + 1**，返回第2步。

**[** 例 **6.11 ]** 已知关系模式**R < U , F>**，其中**U = {A, B, C, D, E}**；**F = { AB → C, B → D, C → E, EC → B, AC → B }**。求**( AB )** **F**。

解 ：由算法**6.1**，设**X** **(0)** **= AB**。 计算**X** **(1)**：逐一的扫描 **F** 集合中各个函数依赖，找左部为 **A**、**B**或**AB**的函数依赖。得到两个：**AB → C**，**B → D**。于 是**X**(1) **= AB** ∪ **CD = ABCD**。

因为**X** **(0)** **≠ X** **(1)**，所以再找出左部为**ABCD**子集的那些函数 依赖，又得到**C → E**，**AC → B**，于是 **X** **(2)** **= X** **(1)** ∪ **BE = ABCDE**。

因为**X** **(2)** 已等于全部属性集合，所以 **(AB)** **F** **= ABCDE**。

## 4. 等价函数依赖集

定义：如果 **G** **+** **= F** **+**，就说函数依赖集 **F** 覆盖 **G** （**F** 是 **G** 的覆盖，或 **G** 是 **F** 的覆盖），或 **F** 与 **G** 等价。

两个函数依赖集等价是指它们的闭包等价

- 函数依赖集等价的充要条件

- 引理**6.3 F** **+** **= G** **+** 的充分必要条件是 **F** ⊆ **G** **+** 和 **G** ⊆ **F** **+** 。

- - 证**:** 必要性显然，只证充分性。

（**1**）若**F** ⊆ **G** **+**，则 **X** **F** **+** ⊆ **X** **G**++。

（**2**）任取 **X → Y** ∈ **F** **+** 则有 **Y** ⊆ **X** **F** **+** ⊆ **X** **G** **++**。 

​     所以**X→Y** ∈ **(G**+)+= G+。即F+⊆ G+。

（**3**）同理可证**G** **+** ⊆ **F**+**，所以**F **+** **= G**+。

如何判定**F** ⊆ **G**+**？只需逐一对**F**中的函数依赖**X→Y**考察 **Y 是否属于**X** **G**++ 

 

## 5. 最小函数依赖集 

- 定义：如果函数依赖集**F**满足下列条件，则称**F**为一个极小函数依赖集，亦称为最小依赖集或最小覆盖。

- - **F** 中任一函数依赖的右部仅含有一个属性。即F中的函数依赖均不能由F中其他函数依赖导出
    - **F** 中不存在这样的函数依赖**X → A**，使得 **F** 与 **F - { X → A }**等价。
    - **F** 中不存在这样的函数依赖**X → A**， **X**有真子集**Z**使得**F - { X → A }** ∪ **{ Z → A }**与 **F** 等价。 F中各函数依赖左部均为最小属性集（不存在冗余属性）

**[**例**6.12]** 考察**6.1**节中的关系模式**S<U,F>**，其中：

**U = { Sno , Sdept, Mname, Cno, Grade}**，

**F = { Sno → Sdept, Sdept → Mname, (Sno,Cno) → Grade} ,** **F**是最小覆盖

**F ' ={ Sno → Sdept, Sno → Mname, Sdept → Mname ,** **(Sno,Cno) → Grade, (Sno,Sdept) → Sdept} ,** **F '**不是最小覆盖

因为：**F '- { Sno → Mname }** 与 **F '** 等价，**F '- { (Sno , Sdept) → Sdept }** 也与 **F '**等价

 

- 定理：每一个函数依赖集**F**均等价于一个极小函数依赖集**F**m**。此**Fm**称为**F的最小依赖集。

- - 证：构造性证明，分三步对**F**进行**“**极小化处理**”**，找出**F**的一个最小依赖集。

（**1**）逐一检查 **F** 中各函数依赖 **FD**i ：**X → Y**，

​     若**Y = A**1A2 **… A**k**，**k ≥ 2，

​      则用**{X → A**j**|** **j = 1,2,…,k}**来取代**X → Y**。

​      引理**6.1**保证了**F**变换前后的等价性。

（**2**）逐一检查**F**中各函数依赖**FD**i**：**X→A，

​      令**G=F-{X→A}**，

​     若**A**∈**X**G+**，则从**F中去掉此函数依赖。

​     由于**F**与**G** 等价的充要条件是**A**∈**X**G+

​     因此**F**变换前后是等价的。

（**3**）逐一取出**F**中各函数依赖**FD**i**：**X→A，

​      设**X=B**1B2…Bm**，**m≥2，

​          逐一考查**B**i**（**i=1**，**2**，**…**，**m），

​      若**A** ∈**(X-B**i)F+**，则以**X-Bi取代X。

 

由于**F**与**F-{X→A}**∪**{Z→A}**等价的充要条件是

**A**∈**Z**F+**，其中**Z=X-Bi**，因此**F变换前后是等价的。

最后剩下的**F**就一定是极小依赖集。

  因为对**F**的每一次“改造”都保证了改造前后的两个函数 

​      依赖集等价，因此剩下的**F**与原来的**F**等价。

  证毕

- 定理**6.3**的证明过程

- - 是求**F**极小依赖集的过程
    - 也是检验**F**是否为极小依赖集的一个算法

  若改造后的**F**与原来的**F**相同，说明**F**就是一个最小依赖集

 

**[**例**6.13] F={A→B, B→A, B→C, A→C, C→A}，**F**的最小依赖集：**Fm1= {A→B, B→C, C→A}

**F**的最小依赖集**F**m不一定是唯一的，它与对各函 数依赖**FDi 及**X→A**中**X**各属性的处置顺序有关。

**F={A→B, B→A, B→C, A→C, C→A}**

  **F**m1**、**Fm2都是**F**的最小依赖集：

​     **F**m1= {A→B, B→C, C→A}

​     **F**m2= {A→B, B→A, A→C, C→A} 

- 在**R<U,F>**中可以用与**F**等价的依赖集**G**来取代**F**

- - 原因：两个关系模式**R**1 **<U,F>**，**R**2<U,G>**，如果**F**与**G**等价，那么R1的关系一定是R2的关系。反过来，**R2的关系也一定是**R**1的关系。 
