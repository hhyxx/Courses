# 一、实体完整性

## 1.定义

在CREATE TABLE中用PRIMARY KEY定义
单属性构成的码有两种说明方法

- 定义为列级约束条件
- 定义为表级约束条件
- 对多个属性构成的码只有一种说明方法
- 定义为表级约束条件

## 2.检查违约和处理

插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。
包括：

- 检查主码值是否唯一，如果不唯一则拒绝插入或修改
- 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改
    检查记录中主码值是否唯一的一种方法是进行全表扫描
- 依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同
- 为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，一般为𝑏+树索引

# 二、参照完整性

## 1.定义

在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码
用REFERENCES短语指明这些外码参照哪些表的主码
定义SC中的参照完整性

```sql
CREATE TABLE SC(
      Sno    CHAR(9)  NOT NULL, 
      Cno     CHAR(4)  NOT NULL,  
      Grade    SMALLINT,
      PRIMARY KEY (Sno, Cno),   /*在表级定义实体完整性*/
      FOREIGN KEY (Sno) REFERENCES Student(Sno),  
      /*在表级定义参照完整性*/
      FOREIGN KEY (Cno) REFERENCES Course(Cno)    
      /*在表级定义参照完整性*/
);
```

## 2.检查违约和处理

### （1）破坏参照完整性的四种情况

- 参照完整性将两个表中的相应元组联系起来
- 对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查
    例如，对表SC和Student有四种可能破坏参照完整性的情况 :
- SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。
- 修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。
- 从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。
- 修改Student表中一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 。
    ![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200617212522675-471058558.png)

### （2）违约处理

- 拒绝（NO ACTION）执行
    - 不允许该操作执行。该策略一般设置为默认策略
- 级联（CASCADE）操作
    - 当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组
- 设置为空值（SET-NULL）
    - 当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。
    - 对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值

```sql
CREATE TABLE SC
        (  Sno   CHAR(9)  NOT NULL，
           Cno   CHAR(4)  NOT NULL，
           Grade  SMALLINT,
           PRIMARY KEY(Sno,Cno)，           
           FOREIGN KEY (Sno) REFERENCES Student(Sno)
        ON DELETE CASCADE        /*级联删除SC表中相应的元组*/
             ON UPDATE CASCADE,      /*级联更新SC表中相应的元组*/
           FOREIGN KEY (Cno) REFERENCES Course(Cno)                    
             ON DELETE NO ACTION   
                 /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/
             ON UPDATE CASCADE  
          /*当更新course表中的cno时，级联更新SC表中相应的元组*/
           );
```

# 三、用户定义完整性

## 1.属性上的约束条件

### （1）定义

- CREATE TABLE时定义属性上的约束条件
    - 列值非空（NOT NULL）
    - 列值唯一（UNIQUE）
    - 检查列值是否满足一个条件表达式（CHECK）
        Student表的Ssex只允许取“男”或“女”。

```sql
CREATE TABLE Student ( 
  Sno  CHAR(9) PRIMARY KEY,
  Sname CHAR(8) NOT NULL,                     
  Ssex  CHAR(2)  CHECK (Ssex IN (‘男’, ‘女’)), /*性别属性Ssex只允许取'男'或'女' */
  Sage  SMALLINT,
  Sdept  CHAR(20)
);
```

SC表的Grade的值应该在0和100之间。

```sql
CREATE TABLE  SC (  
  Sno     CHAR(9) ,
  Cno    CHAR(4),
  Grade   SMALLINT CHECK (Grade>=0 AND Grade <=100), /*Grade取值范围是0到100*/
  PRIMARY KEY (Sno,Cno),
  FOREIGN KEY (Sno) REFERENCES Student(Sno),
  FOREIGN KEY (Cno) REFERENCES Course(Cno)
 );
```

### （2）检查和违约处理

- 插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足
- 如果不满足则操作被拒绝执行

## 2.元组上的约束条件

### （1）定义

- CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制
- 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件
    当学生的性别是男时，其名字不能以Ms.打头。

```sql
CREATE TABLE Student(
  Sno    CHAR(9), 
  Sname  CHAR(8) NOT NULL，
  Ssex    CHAR(2),
  Sage   SMALLINT,
  Sdept  CHAR(20),
  PRIMARY KEY (Sno),
  CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%') /*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/
);
```

性别是女性的元组都能通过该项检查，因为Ssex=‘女’成立;
当性别是男性时，要通过检查则名字一定不能以Ms.打头

### （2）检查和违约处理

- 插入元组或修改属性的值时，关系数据库管理系统检查元组上的约束条件是否被满足
- 如果不满足则操作被拒绝执行

# 四、完整性约束命名字句

## 1.建立约束

建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。

```sql
CREATE TABLE Student (
  Sno  NUMERIC(6)
  CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999),
  Sname  CHAR(20) 
  CONSTRAINT C2 NOT NULL,
  Sage  NUMERIC(3)
  CONSTRAINT C3 CHECK (Sage < 30),
  Ssex  CHAR(2)
  CONSTRAINT C4 CHECK (Ssex IN ( ‘男’,'女')),
  CONSTRAINT StudentKey PRIMARY KEY(Sno)
);
```

## 2.修改约束

修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40
可以先删除原来的约束条件，再增加新的约束条件

```sql
ALTER TABLE Student
DROP CONSTRAINT C1;
ALTER TABLE Student
ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999),
ALTER TABLE Student
DROP CONSTRAINT C3;
ALTER TABLE Student
ADD CONSTRAINT C3 CHECK(Sage < 40);　　
```

# 五、断言

## 1.创建断言

- SQL中使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。
- 可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。
- 断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行
    限制数据库课程最多60名学生选修

```sql
CREATE ASSERTION ASSE_SC_DB_NUM
CHECK (
  60 >= (
    select count(*) /*此断言的谓词涉及聚集操作count的SQL语句*/
    From Course,SC
    Where SC.Cno=Course.Cno and Course.Cname ='数据库'
  )
);
```

限制每一门课程最多60名学生选修

```sql
CREATE ASSERTION ASSE_SC_CNUM1
CHECK(
  60 >= ALL (
    SELECT count(*)                        
    FROM SC 
    GROUP by cno
  )
 );
/*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/
```

限制每个学期每一门课程最多60名学生选修

```sql
/*首先需要修改SC表的模式，增加一个“学期（TERM）”属性*/
ALTER TABLE SC ADD TERM DATE; 
/*然后，定义断言：*/
CREATE ASSERTION ASSE_SC_CNUM2
CHECK(
  60 >= ALL (
    SELECT count(*)                                    
    FROM SC
    GROUP by cno,TERM
  )
);
```

## 2.删除断言

- 删除断言的语句格式为
    - DROP ASSERTION <断言名>;
    - 如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的

## 
