# 一、关系数据库系统的查询处理

## 1.查询处理步骤 

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200605143726074-270196593.png)

 

### （1）查询分析

- 任务：对查询语句进行扫描、词法分析和语法分析
- 词法分析：从查询语句中识别出正确的语言符号 
- 语法分析：进行语法检查

### （2）查询检查

- 查询检查的任务

- - 合法权检查
    - 视图转换
    - 安全性检查
    - 完整性初步检查

- 根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效 

- 如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作

- 根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查

- 检查通过后把**SQL**查询语句转换成内部表示，即等价的关系代数表达式。

- 关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。

### （3）查询优化

- 查询优化：选择一个高效执行的查询处理策略 

- 查询优化分类 

- - 代数优化**/**逻辑优化：指关系代数表达式的优化
    - 物理优化：指存取路径和底层操作算法的选择

- 查询优化的选择依据

- - 基于规则**(rule based)**
    - 基于代价**(cost based)**
    - 基于语义**(semantic based)**

### （4）查询执行

- 依据优化器得到的执行策略生成查询执行计划

- 代码生成器**(code generator)**生成执行查询计划的代码 

- 两种执行方法

- - 自顶向下
    - 自底向上

## 2.查询实现算法

### （1）选择操作的实现

- 全表扫描方法 **(Table Scan)**

- - 对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出 
    - 适合小表，不适合大表

- 假设可以使用的内存为**M**块，全表扫描算法思想：

1. - 按照物理次序读**Student**的**M**块到内存
    - 检查内存的每个元组**t**，如果满足选择条件，则输出**t**
    - 如果**student**还有其他块未被处理，重复**①**和**②**

- 索引扫描方法 **(Index Scan)**
    - 适合于选择条件中的属性上有索引**(**例如**B+**树索引或**Hash**索引**)** 
    - 通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组 

### （2）连接操作的实现

- 连接操作是查询处理中最耗时的操作之一 
- 只讨论等值连接**(**或自然连接**)**最常用的实现算法 

- 嵌套循环算法(nested loop join) 

    

    排序-合并算法(Sort-Merge Join)

    - 对外层循环**(Student**表**)**的每一个元组**(s)**，检索内层循环**(SC**表**)**中的每一个元组**(sc)**
    - 检查这两个元组在连接属性**(Sno)**上是否相等
    - 如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止。

- 

- - 如果连接的表没有排好序，先对**Student**表和**SC**表按连接属性**Sno**排序 
    - 取**Student**表中第一个**Sno**，依次扫描**SC**表中具有相同**Sno**的元组 
    - 当扫描到**Sno**不相同的第一个**SC**元组时，返回**Student**表扫描它的下一个元组，再扫描**SC**表中具有相同**Sno**的元组，把它们连接起来 
    - 重复上述步骤直到**Student** 表扫描完
    - **Student**表和**SC**表都只要扫描一遍
    - 如果两个表原来无序，执行时间要加上对两个表的排序时间
    - 对于大表，先排序后使用排序**-**合并连接算法执行连接，总的时间一般仍会减少

![img](https://img2020.cnblogs.com/blog/1861185/202006/1861185-20200605161642789-1372225532.png)

- 索引连接(index join)算法 
    - **①**在**SC**表上已经建立属性**Sno**的索引。
    - **②**对**Student**中每一个元组，由**Sno**值通过**SC**的索引查找相应的**SC**元组。 
    - **③**把这些**SC**元组和**Student**元组连接起来  
    - 循环执行**②③**，直到**Student**表中的元组处理完为止 
- **Hash Join**算法
    - 把连接属性作为**hash**码，用同一个**hash**函数把**Student**表和**SC**表中的元组散列到**hash**表中。
        - 算法前提：假设两个表中较小的表在第一阶段后可以完全放入内存的**hash**桶中 
    - 划分阶段**(building phase,** 也称为**partitioning phase)**
        - 对包含较少元组的表**(**如**Student**表**)**进行一遍处理
        - 把它的元组按**hash**函数分散到**hash**表的桶中
    - 试探阶段**(probing phase,**也称为连接阶段**join phase)** 
        - 对另一个表**(SC**表**)**进行一遍处理
        - 把**SC**表的元组也按同一个**hash**函数（**hash**码是连接属性）进行散列
        - 把**SC**元组与桶中来自**Student**表并与之相匹配的元组连接起来

# 二、关系数据库系统的查询优化

## 1.概述

### （1）优点好处

- 用户不必考虑如何最好地表达查询以获得较好的效率

- 系统可以比用户程序的**“**优化**”**做得更好 

- - 优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。
    - 如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。
    - 优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。
    - 优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。

### （2）代价模型

- 集中式数据库

    分布式数据库

    分布式数据库

    - 执行开销主要包括
        - 磁盘存取块数**(I/O**代价**)**
        - 处理机时间**(CPU**代价**)**
        - 查询的内存开销 
    - **I/O**代价是最主要的 

- - 总代价**=I/O**代价**+CPU**代价**+**内存代价＋通信代价 

- 查询优化的总目标

- - 选择有效的策略
    - 求得给定关系表达式的值
    - 使得查询代价最小**(**实际上是较小**)** 

## 2.实例

一个关系查询可以对应不同的执行方案，其效率可能相差非常大。

- **[**例**9.3]** 求选修了**2**号课程的学生姓名。

  用**SQL**表达：

   **SELECT Student.Sname**

　　**FROM   Student, SC**

　　**WHERE  Student.Sno=SC.Sno AND    SC.Cno='2'** 

- 假定 学生**-**课程数据库 中有**1000**个学生记录，**10000**个选课记录
- 选修**2**号课程的选课记录为**50**个 

- 可以用多种等价的关系代数表达式来完成这一查询

- - $Q1= πSname(σStudent.Sno = SC.Sno ∧ SC.Cno = '2'(Student × SC) )$
    - $Q2=πSname( σSC.Cno = '2'(Student ⋈ SC) )$
    - $Q3= πSname(Student ⋈ σSC.Cno = '2'(SC))$

- 第一种情况 ：$Q1= πSname(σStudent.Sno = SC.Sno∧SC.Cno = '2'(Student × SC) )$

- - 计算笛卡尔积

    - - 内存中尽可能多地装入某个表**(**如**Student**表**)**的若干块，留出一块存放另一个表**(**如**SC**表**)**的元组。

        - 把**SC**中的每个元组和**Student**中每个元组连接，连接后的元组装满一块后就写到中间文件上

        - 从**SC**中读入一块和内存中的**Student**元组连接，直到**SC**表处理完。

        - 再读入若干块**Student**元组，读入一块**SC**元组

        - 重复上述处理过程，直到把**Student**表处理完 

        - 设一个块能装**10**个**Student**元组或**100**个**SC**元组，在内存中存放**5**块**Student**元组和**1**块**SC**元组，则读取总块数为

            读**Student**表**100**块，读**SC**表**20**遍，每遍**100**块，则总计要读取**2100**数据块。

            - 100010+100010×5×10000100=100+20×100=2100100010+100010×5×10000100=100+20×100=2100块                                  

        - 连接后的元组数为103×104=107。设每块能装**10**个元组，则写出106块。

    - 作选择操作

    - - 依次读入连接后的元组，按照选择条件选取满足要求的记录
        - 假定内存处理时间忽略。读取中间文件花费的时间**(**同写中间文件一样**)**需读入106块。 
        - 若满足条件的元组假设仅**50**个，均可放在内存。

    - 作投影操作

        - 把第（**2**）步的结果在**Sname**上作投影输出，得到最终结果 

- - 第一种情况下执行查询的总读写数据块=2100+106+106
- 第二种情况：$Q2=πSname( σSc.Cno = '2'(Student⋈SC) )$
    - 计算自然连接 
        - 执行自然连接，读取**Student**和**SC**表的策略不变，总的读取块数仍为**2100**块
        - 自然连接的结果比第一种情况大大减少，为**10****4**个元组
        - 写出数据块103 块
    - 读取中间文件块，执行选择运算，读取的数据块103 块
    - 把第**2**步结果投影输出。
        - 第二种情况下执行查询的总读写数据块=2100+103+103
        - 其执行代价大约是第一种情况的**488**分之一
- 第三种情况：$Q3=πSname(Student⋈σSC.Cno = '2'(SC))$​​​​​​​​
    - 先对**SC**表作选择运算，只需读一遍**SC**表，存取**100**块，因为满足条件的元组仅**50**个，不必使用中间文件。
    - 读取**Student**表，把读入的**Student**元组和内存中的**SC**元组作连接。也只需读一遍**Student**表共**100**块。
    - 把连接结果投影输出 
        - 第三种情况总的读写数据块**=100+100**
        - 其执行代价大约是第一种情况的万分之一，是第二种情况的**20**分之一

- 代数优化

    - 假如**SC**表的**Cno**字段上有索引

    - - 第一步就不必读取所有的**SC**元组而只需读取**Cno=‘2’**的那些元组**(50**个**)**
        - 存取的索引块和**SC**中满足条件的数据块大约总共**3**～**4**块

    - 若**Student**表在**Sno**上也有索引

    - - 不必读取所有的**Student**元组
        - 因为满足条件的**SC**记录仅**50**个，涉及最多**50**个**Student**记录

    - - 读取**Student**表的块数也可大大减少 

    - 把代数表达式**Q1**变换为**Q2**、 **Q3**

    $$
    \begin{align}
    & Q_1  = πSname(σStudent.Sno = SC.Sno∧Sc.Cno = '2'(Student × SC)) \\
    \implies & Q_2 = \pi Sname(\sigma Sc.Cno='2' (Student \bowtie SC)) \\
    \implies & \mathrm{Q} 3=\pi \text { Sname }\left(\text { Student } \bowtie \sigma S C . C n o=' 2^{\prime}(S C)\right)
    \end{align}
    $$

    

    - - 有选择和连接操作时，先做选择操作，这样参加连接的元组就可以大大减少，这是代数优化

# 三、代数优化

## **1.** 关系代数表达式等价变换规则 

### （1）常用的等价变换规则

- 连接、笛卡尔积交换律

    - 设E1和E2是关系代数表达式，F是连接运算的条件，则有

    
    $$
    \begin{array}{l}
    E_1 \times E_2 \equiv E_2 \times E_1 \\ 
    E_1 \bowtie E_2 \equiv E_2 \bowtie E_1 \\ 
    E_1 \bowtie E_2 \equiv E_2 \bowtie E_1
    \end{array}
    $$

- 连接、笛卡尔积的结合律

    - 设E1,E2,E3是关系代数表达式，F1,F2是连接运算的条件

    $$
    \begin{array}{l}
    (E 1 \times E 2) \times E 3 \equiv E 1 \times(E 2 \times E 3)\\
    (E 1 \bowtie E 2)\bowtie E 3 \equiv  E_1 \bowtie ( E 2 \bowtie E 3) \\
    (E 1 \bowtie F 1 E 2)\bowtie F 2 E 3 \equiv  E_1 \bowtie (F1  E 2 \bowtie F2 E 3) 
    \end{array}
    $$

    

- 投影的串接定律：$πA1,A2,⋯,An(πB1,B2,⋯Bm(E))≡πA1,A2,⋯An(E)$​

    - E是关系代数表达式
    - $A_i(i=1,2,\cdots,n),B_j(j=1,2,\cdots,m)$是属性名
    - ${A_1,\cdots,A_n}$构成的$B_1,\cdots,B_m$子集

**4.**选择的串接定律

- $σF1(σF2(E))≡σF1∧F2(E)$

- - **E**是关系代数表达式，F1,F2是选择条件
    - 选择的串接律说明选择条件可以合并**,**这样一次就可检查全部条件

**5.**选择与投影操作的交换律

- σF(πA1,A2,⋯,An(E))≡πA1,A2,⋯An(σF(E))
    - 选择条件**F**只涉及属性A1,..., An
    - 若**F**中有不属于A1,...,An的属性B1,...,Bm有更一般规则：

- $πA1,A2,⋯An(σF(E))≡πA1,A2,⋯,An(σF(πA1,A2,⋯,An,B1,B2,⋯Bm(E)))$

**6.** 选择与笛卡尔积的交换律

- 如果**F**中涉及的属性都是E1中的属性，则**𝜎𝐹(𝐸1×𝐸2)≡𝜎𝐹(𝐸1)×𝐸2σF(E1×E2)≡σF(E1)×E2**
- 如果F=F1∧F2，并且F1只涉及E1中的属性，F2只涉及E2中的属性，则由上面的等价变换规则**1**，**4**，**6**可推出：σF(E1×E2)≡σF1(E1)×σF2(E2)
- 若F1只涉及 E1中的属性 F2涉及 E1和 E2两者的属性，则仍有σF(E1×E2)≡σF2(σF1(E1)×E2)它使部分选择在笛卡尔积前先做。 

**7.** 选择与并的分配律

- 设E1与E2有相同的属性名，则 σF(E1 ∪ E2)≡σF(E1) ∪ σF(E2)

**8.** 选择与差运算的分配律

- 设E1与E2有相同的属性名，则 σF(E1-E2) ≡ σF(E1) - σF(E2)

**9.** 选择对自然连接的分配律

-   σF(E1⋈E2)  ≡  σF(E1) ⋈ σF(E2)  
-   **F**只涉及E1 和E2的公共属性 

10.投影与笛卡尔积的分配律

　　设E1和E2是两个关系表达式，A1，…，An是E1的属性，  

   B1，…，Bm是E2的属性，则
$$
πA1,A2,⋯,An,B1,B2,⋯Bm(E1×E2)≡πA1,A2,⋯An(E1)×πB1,B2,⋯Bm(E2)
$$
11.投影与并的分配律 设E1和E2有相同的属性名，则
$$
πA1,A2,⋯,An(E1∪E2)≡πA1,A2,⋯,An(E1)∪πA1,A2,⋯,An(E2)
$$


## **2.** 查询树的启发式优化 

（1）启发式优化规则

- 选择运算应尽可能先做，把投影运算和选择运算同时进行

    - 在优化策略中这是最重要、最基本的一条。

- - 如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。

- 把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。

- 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间

- 找出公共子表达式

    - 如果这种重复出现的子表达式的结果不是很大的关系
    - 并且从外存中读入这个关系比计算该子表达式的时间少得多
    - 则先计算一次公共子表达式并把结果写入中间文件是合算的。
    - 当查询的是视图时，定义视图的表达式就是公共子表达式的情况
